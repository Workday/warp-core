buildscript {
    // set a valid scala suffix for the buildscript itself
    project.ext.scalaSuffix = '_2.12'
    apply from: file("${rootDir}/versionInfo.gradle")

    repositories {
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "com.adtran:scala-multiversion-plugin:${versions.scalaMultiversion}"
        classpath "com.netflix.nebula:gradle-git-scm-plugin:${versions.nebulaGit}"
        classpath "com.netflix.nebula:nebula-release-plugin:${versions.nebulaRelease}"
        classpath "com.netflix.nebula:nebula-publishing-plugin:${versions.nebulaPublish}"
        classpath "io.github.cosmicsilence:gradle-scalafix:${versions.scalafix}"
        classpath "org.ajoberstar.grgit:grgit-gradle:${versions.gradleGit}"
        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${versions.coveralls}"
        classpath "org.scoverage:gradle-scoverage:${versions.gradleScoverage}"
        classpath "com.github.alisiikh:gradle-scalastyle-plugin:${versions.scalaStyle}"
    }

    // lock buildscript dependencies
    configurations.classpath {
        resolutionStrategy.activateDependencyLocking()
    }
}


allprojects {
    apply plugin: 'base'
    apply plugin: 'java-library'
    apply plugin: 'checkstyle'
    apply plugin: 'scala'
    // apply multiversion to individual projects
    apply plugin: 'com.adtran.scala-multiversion-plugin'
    apply plugin: 'idea'
    apply plugin: 'org.ajoberstar.grgit'
    apply plugin: 'nebula.gradle-git-scm'
    apply plugin: 'nebula.release'
    apply plugin: 'nebula.maven-resolved-dependencies'
    apply plugin: 'com.github.alisiikh.scalastyle'
    apply plugin: 'org.scoverage'
// must be applied after scoverage
    apply plugin: 'io.github.cosmicsilence.scalafix'
    apply plugin: 'com.github.kt3k.coveralls'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'
    apply from: file("${rootDir}/versionInfo.gradle")

    repositories {
        mavenLocal()
        mavenCentral()
    }

    // we want uniform explicit control over scala version rather than potentially transitively pulling a different version
    dependencies {
        api ("org.scala-lang:scala-library") {
            version {
                strictly "%scala-version%"
            }
        }
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${versions.junit5}"
        testRuntimeOnly("org.junit.vintage:junit-vintage-engine:${versions.junit5}") {
            because 'allows JUnit 3 and JUnit 4 tests to run'
        }
        testRuntimeOnly("org.junit.platform:junit-platform-launcher:${versions.junit5PlatformLauncher}") {
            because 'allows tests to run from IDEs that bundle older version of launcher'
        }

        api "org.scala-lang.modules:scala-collection-compat_%%:${versions.scalaCollectionCompat}"

    }

    scalastyle {
        scalaVersion = '2.13'
        config = file("${rootDir}/scalastyle.xml")
    }

    // avoid an error like:
    // Execution failed for task ':warp-core-root_2.13.6:warp-core:clean'.
    // > java.io.IOException: Unable to delete directory '~/code/warp-core-root/warp-core/build'
    // New files were found. This might happen because a process is still writing to the target directory.
    buildDir customBuildDir(project, scalaVersion) //"$projectDir/build_$scalaVersion"

    scoverage {
        scoverageVersion.set("${versions.scalacScoverage}")
        scoverageScalaVersion.set("$scalaVersion")
        dataDir.set(new File(customBuildDir(project, scalaVersion), "scoverage"))
        reportDir.set(new File(customBuildDir(project, scalaVersion), ScoveragePlugin.DEFAULT_REPORT_DIR))
        // Excluding autogenerated Tables
        excludedPackages.set(["com.workday.warp.persistence.model", "com.workday.warp.examples"])
        // Default Coverage Type is "Statement"
        minimumRate.set(0.88)
    }
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

project(':warp-core') {
    dependencies {

    }
}

project(':warp-core-gatling') {
    dependencies {
        api project(':warp-core')
    }
}

project(':warp-core-macros') {
    dependencies {
        api project(':warp-core')
    }
}

// copy config template into a usable place
// note this task does not have any dependencies, and nothing depends on this task.
// the expectation is this task will always be run in a ci environment,
// and can be run once locally on a fresh checkout to create a starting config point
task copyMySQLConfigTemplate(type: Copy) {
    from "$rootDir/config-templates/warp.properties.mysql.template"
    rename { String filename ->
        'warp.properties'
    }

    into "$rootDir/config/"
}
task copyH2ConfigTemplate(type: Copy) {
    from "$rootDir/config-templates/warp.properties.h2.template"
    rename { String filename ->
        'warp.properties'
    }

    into "$rootDir/config/"
}


import org.apache.tools.ant.filters.ReplaceTokens
import io.github.cosmicsilence.scalafix.ScalafixTask
import org.scoverage.ScoveragePlugin

/**
 * @return true iff we are building a maven snapshot or a devSnapshot.
 */
static boolean isSnapshot(String inferredVersion) {
    inferredVersion.endsWith("-SNAPSHOT") || inferredVersion.contains("-dev.") || inferredVersion.contains(".dev.")
}

static String customBuildDir(Project p, String scalaVersion) {
    "${p.projectDir}/build_$scalaVersion"
}


subprojects {
    apply from: file('dependencies.gradle')

    sourceSets {
        main {
            // joint compilation
            scala {
                srcDir 'src/main/java'
                srcDir 'src/main/scala'
                // we want our generated code to live in a separate directory so we can easily skip scalastyle and scalafix,
                // however its convenient to treat this as part of the same source set and compile everything together
                srcDir 'src/generated/scala'
            }
            java {
                srcDirs = [] // don't compile Java code twice
            }

        }

        test {
            // joint compilation
            scala {
                srcDir 'src/test/java'
                srcDir 'src/test/scala'
            }
            java {
                srcDirs = [] // don't compile Java code twice
            }
        }

    }


    processResources {
        filter(ReplaceTokens, tokens: ['version': project.version.toString()])
    }

    task sourcesJar(type: Jar) {
        duplicatesStrategy = 'include'
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }

// fake javadoc jar to pass sonatype rules
// See https://central.sonatype.org/pages/requirements.html
    task javadocJar(type: Jar) {
        duplicatesStrategy = 'include'
        archiveClassifier = 'javadoc'
        from new File("$rootDir/javadoc-fake")
    }

    task scaladocJar(type: Jar) {
        duplicatesStrategy = 'include'
        archiveClassifier = 'scaladoc'
        from scaladoc.destinationDir
    }

    scaladoc {
        classpath = sourceSets.main.runtimeClasspath
        destinationDir file("$rootDir/gh-pages-src/static/scaladoc/${project.name}")
    }

    tasks.withType(ScalaCompile) {
        scalaCompileOptions.additionalParameters = [
                // needed for "RemoveUnused" scalafix rule
                '-Ywarn-unused',
                // so we can avoid importing scala.language.postfixOps in multiple source files
                '-language:postfixOps',
                // gets rid of "Static methods in interface require -target:jvm-1.8" error
                '-target:jvm-1.8',
                // uncomment to show emitted macro code (very noisy)
                // '-Ymacro-debug-lite'
        ]
    }

    task unitTest(type: Test) {
        useJUnitPlatform {
            includeTags 'unitTest'
            excludeTags 'integTest', 'ci'
        }
    }

    test {
        minHeapSize = "500m"
        maxHeapSize = "12g"

        testLogging {
            events 'failed'
            showStandardStreams = "$showTestStandardStreams".toBoolean()
        }

        useJUnitPlatform()
    }

    task deleteSchema(type: JavaExec, dependsOn: compileTestScala) {
        description = "deletes the db schema prior to running tests"
        main = "com.workday.warp.persistence.DropCoreSchema"
        classpath = sourceSets.main.runtimeClasspath
        doLast {
            println("gradle task deleted schema")
        }
    }

    checkstyle {
        toolVersion = "${versions.checkstyle}"
        configFile = new File("${rootDir}/checkstyle.xml")
    }

    tasks.withType(JavaExec).each { task ->
        task.systemProperties(System.properties)
        task.systemProperty "wd.warp.config.directory", "$rootDir/config"
        task.systemProperty "wd.warp.build.output.directory.path", buildDir
        task.jvmArgs = ["--add-exports=jdk.attach/sun.tools.attach=ALL-UNNAMED"]
    }

    tasks.withType(Test).each { task ->
        if (project.hasProperty("shouldDeleteSchema") && Boolean.valueOf(project.shouldDeleteSchema.toString())) {
            task.dependsOn(deleteSchema)
        }
        task.finalizedBy(scalastyleCheck)
        task.finalizedBy(checkstyleMain)
        task.finalizedBy(checkstyleTest)

        task.systemProperties(System.properties)
        task.systemProperty "wd.warp.config.directory", "$rootDir/config"
        task.systemProperty "jdk.attach.allowAttachSelf", "true"
        task.systemProperty "wd.warp.build.output.directory.path", buildDir
        task.jvmArgs = ["--add-exports=jdk.attach/sun.tools.attach=ALL-UNNAMED"]
    }

    coveralls {
        coberturaReportPath = "${buildDir}/reports/scoverage${scalaSuffix}/cobertura.xml"
    }


    scalafix {
        excludes = ["**/persistence/model/**"]
        ignoreSourceSets = ["scoverage"]
        semanticdb {
            autoConfigure = true
            version = "${versions.semanticDb}"
        }
    }


// current workaround nebula incremental analysis failure
// see: https://github.com/gradle/gradle/issues/6854
    configurations.all {
        if (name.startsWith("incrementalScalaAnalysis")) {
            extendsFrom = []
        }
    }


// sonatype doesn't support gradle module metadata (gradle 6 auto feature) yet
// see https://discuss.gradle.org/t/unable-to-publish-artifact-to-mavencentral/33727
    tasks.withType(GenerateModuleMetadata) {
        enabled = false
    }

    afterEvaluate {
        if (project.scalaSuffix != "_2.13") {
            tasks.withType(ScalafixTask) {
                enabled = false
            }
        }
    }

    dependencyLocking {
        lockAllConfigurations()
        if (project.scalaSuffix == "_2.13") {
            lockMode = LockMode.STRICT
        }
        lockFile = file("$projectDir/locking/${project.name}${scalaSuffix}.lockfile")
    }


// taken from https://docs.gradle.org/6.2.1/userguide/dependency_locking.html#generating_and_updating_dependency_locks
// make sure to invoke with --write-locks flag
    task resolveAndLockAll {
        doFirst {
            assert gradle.startParameter.writeDependencyLocks
        }
        doLast {
            configurations.findAll {
                // Add any custom filtering on the configurations to be resolved
                it.canBeResolved
            }.each { it.resolve() }
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                groupId = 'com.workday.warp'
                artifactId = project.name
                from components.java
                artifact sourcesJar
                artifact javadocJar
                artifact scaladocJar
                pom {
                    name = project.name
                    project.description = 'A library for scientific performance testing.'
                    url = 'https://workday.github.io/warp-core/'
                    licenses {
                        license {
                            name = 'MIT License'
                            url = 'https://opensource.org/licenses/mit-license.php'
                        }
                    }
                    developers {
                        developer {
                            id = 'tomnis'
                            name = 'tomas mccandless'
                            email = 'tomas.mccandless@gmail.com'
                        }
                        developer {
                            id = 'tsoppet'
                            name = 'timothy soppet'
                            email = 'tsoppet@gmail.com'
                        }
                        developer {
                            id = 'rooeque'
                            name = 'richie wang'
                            email = 'wang.ruiqi.94@gmail.com'
                        }
                        developer {
                            id = 'sarcasticsimba'
                            name = 'vignesh kalidas'
                            email = 'vignesh10010@gmail.com'
                        }
                    }
                    scm {
                        connection = 'scm:git:git://github.com/Workday/warp-core.git'
                        developerConnection = 'scm:git:ssh://github.com:Workday/warp-core.git'
                        url = 'https://github.com/Workday/warp-core/tree/master'
                    }
                }
            }
        }

        repositories {
            maven {
                credentials {
                    // will be null if these aren't set as project properties
                    username findProperty("sonatypeUsername")
                    password findProperty("sonatypePassword")
                }
                String snapshotsRepoUrl = 'https://oss.sonatype.org/content/repositories/snapshots'
                String releasesRepoUrl = 'https://oss.sonatype.org/service/local/staging/deploy/maven2'
                url = isSnapshot(version.toString()) ? snapshotsRepoUrl : releasesRepoUrl
            }
        }
    }

    nebulaRelease {
        addReleaseBranchPattern(".*feature")
    }

    signing {
        // only require signing for non-snapshot versions being published to maven central
        required {
            !isSnapshot(version.toString()) && gradle.taskGraph.hasTask("publish")
        }
        sign publishing.publications.mavenJava
    }
}
